# Отчет о проблемах синхронизации удалений

## Дата: 2024

## Проблема

При удалении сущностей в мобильном приложении (app-crm) они правильно помечаются для удаления и отправляются на сервер через синхронизацию, но после следующей синхронизации эти сущности возвращаются обратно в приложение.

## Затронутые сущности

1. **Клиенты** (`clients`)
2. **Группы клиентов** (`client_groups`)
3. **Объекты** (`sites`)
4. **Установки** (`installations`)
5. **Компоненты** (`components`)

## Как работает удаление в клиентской части

### 1. Процесс удаления

Когда пользователь удаляет сущность в приложении:

1. Вызывается соответствующий метод из `SafeDeletionHelper`:
   - `deleteClient()` - для клиентов
   - `deleteClientGroup()` - для групп клиентов
   - `deleteSite()` - для объектов
   - `deleteInstallation()` - для установок
   - `deleteComponent()` - для компонентов

2. Каждый метод:
   - Физически удаляет запись из локальной базы данных (Room)
   - Вызывает `DeletionTracker.markXXXDeleted()`, который создает запись в таблице `deleted_records`

3. При синхронизации:
   - Записи из `deleted_records` с `dirtyFlag = true` отправляются на сервер в секции `deleted` запроса `sync/push`
   - После успешной отправки записи помечаются как синхронизированные (`dirtyFlag = false`)

### 2. Формат отправки удалений

Удаления отправляются в следующем формате:

```json
{
  "deleted": [
    {
      "entity": "clients",  // или "client_groups", "sites", "installations", "components"
      "recordId": "uuid-клиента",
      "deletedAtEpoch": 1234567890
    }
  ]
}
```

### 3. Ожидаемое поведение сервера

После получения удалений сервер должен:

1. **Удалить записи из базы данных** (или пометить как удаленные, если используется soft delete)
2. **Не возвращать эти записи** в следующих ответах `sync/pull`
3. **Отправить подтверждение удаления** в ответе `sync/push` (если требуется)

## Текущее поведение (проблема)

После синхронизации удаленные сущности **возвращаются обратно** в приложение. Это означает, что:

1. Сервер **не удаляет** записи из базы данных, или
2. Сервер **возвращает удаленные записи** в ответе `sync/pull`, или
3. Сервер **не обрабатывает** секцию `deleted` в запросе `sync/push`

## Проверка на стороне сервера

Необходимо проверить следующие моменты:

### 1. Обработка секции `deleted` в `sync/push`

- [ ] Сервер читает массив `deleted` из запроса
- [ ] Для каждой записи в `deleted` сервер удаляет соответствующую запись из БД
- [ ] Сервер логирует обработку удалений
- [ ] Сервер возвращает ошибки, если удаление не удалось

### 2. Фильтрация удаленных записей в `sync/pull`

- [ ] Сервер **не возвращает** удаленные записи в ответе `sync/pull`
- [ ] Если используется soft delete, сервер фильтрует записи с `deletedAtEpoch != null`
- [ ] Сервер не возвращает записи, которые были удалены, даже если они есть в БД

### 3. Обработка групп клиентов

- [ ] Сервер обрабатывает удаление групп клиентов (`client_groups`)
- [ ] При удалении группы клиенты из этой группы перемещаются в "без группы" (или обрабатываются иначе)

## Примеры кода для проверки

### Обработка удалений в sync/push (пример для Node.js/Express)

```javascript
app.post('/api/sync/push', async (req, res) => {
  const { deleted } = req.body;
  
  if (deleted && deleted.length > 0) {
    console.log(`Получено ${deleted.length} удалений для обработки`);
    
    for (const deletion of deleted) {
      const { entity, recordId, deletedAtEpoch } = deletion;
      
      try {
        switch (entity) {
          case 'clients':
            await db.clients.delete(recordId);
            break;
          case 'client_groups':
            await db.clientGroups.delete(recordId);
            break;
          case 'sites':
            await db.sites.delete(recordId);
            break;
          case 'installations':
            await db.installations.delete(recordId);
            break;
          case 'components':
            await db.components.delete(recordId);
            break;
          default:
            console.warn(`Неизвестная сущность для удаления: ${entity}`);
        }
        
        console.log(`Удалена запись: ${entity}/${recordId}`);
      } catch (error) {
        console.error(`Ошибка удаления ${entity}/${recordId}:`, error);
        // Возможно, стоит вернуть ошибку клиенту
      }
    }
  }
  
  // ... остальная логика синхронизации
});
```

### Фильтрация удаленных записей в sync/pull

```javascript
app.post('/api/sync/pull', async (req, res) => {
  // ... получение данных
  
  // ВАЖНО: Не возвращаем удаленные записи
  const clients = await db.clients.findMany({
    where: {
      deletedAtEpoch: null  // или isDeleted: false
    }
  });
  
  // Аналогично для других сущностей
  const sites = await db.sites.findMany({
    where: {
      deletedAtEpoch: null
    }
  });
  
  // ... остальная логика
});
```

## Исправления в клиентской части

Следующие исправления уже внесены в клиентскую часть:

1. ✅ **Удаление шаблонов компонентов**: Теперь используется `SafeDeletionHelper.deleteComponentTemplate()`, который правильно помечает шаблоны для удаления
2. ✅ **Обработка удаления групп клиентов**: Добавлена обработка удаления групп клиентов в синхронизации pull (`handleDeletedRecord`)

## Рекомендации

1. **Проверить логи сервера** на наличие ошибок при обработке удалений
2. **Добавить логирование** обработки удалений на сервере
3. **Проверить фильтрацию** удаленных записей в `sync/pull`
4. **Убедиться**, что сервер действительно удаляет записи из БД, а не только помечает как удаленные
5. **Проверить транзакции** - возможно, удаления не коммитятся в БД

## Контакты

Если нужна дополнительная информация о формате данных или логике синхронизации, см. код в:
- `app-crm/src/main/java/com/example/wassertech/sync/SyncEngine.kt`
- `app-crm/src/main/java/com/example/wassertech/sync/SafeDeletionHelper.kt`
- `app-crm/src/main/java/com/example/wassertech/sync/DeletionTracker.kt`

